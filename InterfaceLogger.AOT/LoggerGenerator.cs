using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace InterfaceLogger.AOT;

[Generator]
public class LoggerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var classDeclarations = context.SyntaxProvider.CreateSyntaxProvider(
                                                                predicate: NewMethod,
                                                                transform: GetTypeSymbols)
                                                    .Collect();
        context.RegisterSourceOutput(classDeclarations, GenerateSource);
    }

    private bool NewMethod(SyntaxNode node, CancellationToken ct)
        => node is ClassDeclarationSyntax;

    private void GenerateSource(SourceProductionContext context, ImmutableArray<ITypeSymbol> typeSymbols)
    {
        const string factorySignature = "global::InterfaceLogger.Interfaces.ILoggerFactory";

        static bool IsValidSymbol(ITypeSymbol symbol)
            => symbol is not null
                && symbol.AllInterfaces.Any(i => i.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat) == factorySignature);

        var sb = new StringBuilder();
        foreach (var symbol in typeSymbols.Where(IsValidSymbol))
        {
            var methods = symbol.GetMembers()
                                .Select(m => m as IMethodSymbol)
                                .Where(m => m?.IsPartialDefinition ?? false).ToArray();

            if (methods.Length == 0)
                continue;

            InitiateFactory(symbol, sb);

            foreach(var method in methods)
            {
                GenerateLogger(method, sb);
            }
            FinishFactory(symbol, sb);

            //sb.AppendLine("// " + symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
        }

        context.AddSource($"all_typos.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }


    private void InitiateFactory(ITypeSymbol symbol, StringBuilder sb)
    {
        var visibility = symbol.Visibility();
        var s = $$"""
            // ‼️ This file is autogenerated by InterfaceLogger.AOT
            namespace {{symbol.ContainingNamespace}}
            {
                {{visibility}} partial class {{symbol.Name}}
                {
            """;
        sb.AppendLine(s);
    }
    private void FinishFactory(ITypeSymbol _, StringBuilder sb)
        => sb.AppendLine("    }").Append("}");

    private void GenerateLogger(IMethodSymbol method, StringBuilder sb)
    {
        var logIFace = method.ReturnType;
        var logIFaceName = logIFace.Name;
        var logInstanceGetterName = method.Name;
        var logClassName = $"Generated_{logIFaceName}";
        var visibility = method.Visibility();
        var logIFaceVisibility = logIFace.Visibility();
        var s = $$"""
                     {{visibility}} partial {{logIFaceName}} {{logInstanceGetterName}}()
                         => new {{logClassName}}();

                     {{logIFaceVisibility}} class {{logClassName}} : InterfaceLogger.AotLogger<{{logIFaceName}}>, {{logIFaceName}}
                     {
             """;
        sb.AppendLine(s);

        foreach(var logMethod in logIFace.GetMembers().Where(m => m is IMethodSymbol).Cast<IMethodSymbol>())
        {
            var logMethodName = logMethod.Name;
            var paramdef = logMethod.Parameters.Select(p => $"{p.OriginalDefinition.Type} {p.Name}").JoinString(", ");
            var paramlst = new[] { logMethodName.Quoted() }.Concat(logMethod.Parameters.Select(p => p.Name)).JoinString(", ");
            s = $$"""
                            public {{logMethod.ReturnType.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat)}} {{logMethodName}}({{paramdef}})
                                => base.Log(this, {{paramlst}});
                """;
            sb.AppendLine(s);
        }
        s = "        }";
        sb.AppendLine(s);
    }

    private ITypeSymbol GetTypeSymbols(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var decl = (ClassDeclarationSyntax)context.Node;

        if (context.SemanticModel.GetDeclaredSymbol(decl, cancellationToken) is ITypeSymbol typeSymbol)
        {
            return typeSymbol;
        }

        return null;
    }
}
